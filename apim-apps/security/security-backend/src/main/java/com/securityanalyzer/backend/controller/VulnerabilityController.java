package com.securityanalyzer.backend.controller;

import com.securityanalyzer.backend.entity.Body;
import com.securityanalyzer.backend.entity.Constant;
import com.securityanalyzer.backend.entity.Vulnerability;
import com.securityanalyzer.backend.service.VulnerabilityService;
import com.securityanalyzer.backend.util.ApplicationUtils;
import org.eclipse.jgit.api.Git;
import org.eclipse.jgit.api.errors.GitAPIException;
import org.eclipse.jgit.api.errors.InvalidRemoteException;
import org.eclipse.jgit.api.errors.TransportException;
import org.eclipse.jgit.lib.Ref;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.io.FileNotFoundException;
import java.net.http.HttpHeaders;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.List;
/**
 * * VulnerabilityController class is responsible for
 * processing incoming REST API requests related to Vulnerability objects.
 */

@RestController
@CrossOrigin(origins = {"http://localhost:3000"})
@RequestMapping("/api/vulnerabilities")
public class VulnerabilityController {

    private final VulnerabilityService vulnerabilityService;
    private static Logger LOGGER = (Logger) LoggerFactory.getLogger(ApplicationUtils.class);

    public VulnerabilityController(VulnerabilityService vulnerabilityService) {

        this.vulnerabilityService = vulnerabilityService;
    }

    @GetMapping("/{Portal}/{Branch}")
    public ResponseEntity<ArrayList<Vulnerability>> getAllVulnerabilitiesByPortal(@PathVariable("Portal") String portalName, @PathVariable("Branch")String branchName) throws FileNotFoundException {


        try {
            ArrayList<Vulnerability> vulnerabilities = (ArrayList<Vulnerability>) vulnerabilityService.getAllVulnerabilitiesByPortal(portalName, branchName);


            return new ResponseEntity<ArrayList<Vulnerability>>(vulnerabilities, HttpStatus.OK);

        } catch (FileNotFoundException e) {


            return (ResponseEntity<ArrayList<Vulnerability>>) ResponseEntity.badRequest().header("Error Message","Json File not found."). body(new ArrayList<Vulnerability>());

        }

    }
    @GetMapping("/{Portal}/{Branch}/fileLastModifiedTime")
    public Date getLastModifiedTime(@PathVariable("Portal") String portalName,@PathVariable("Branch") String branchName){

        return vulnerabilityService.getLastModifiedTime(portalName,branchName);
    }

    @GetMapping("fetchBranches")
    public  List<String> fetchGitBranches()
    {
        Collection<org.eclipse.jgit.lib.Ref> refs;
        List<String> branches = new ArrayList<String>();
        try {
            refs = Git.lsRemoteRepository()
                    .setHeads(true)
                    .setRemote(Constant.APIM_APPS_REPOSITORY_URL)
                    .call();
            for (Ref ref : refs) {
                branches.add(ref.getName().substring(ref.getName().lastIndexOf("/")+1, ref.getName().length()));
            }
            Collections.sort(branches);
        } catch (InvalidRemoteException e) {
            LOGGER.error(" InvalidRemoteException occured in fetchGitBranches",e);
            e.printStackTrace();
        } catch (TransportException e) {
            LOGGER.error(" TransportException occurred in fetchGitBranches",e);
        } catch (GitAPIException e) {
            LOGGER.error(" GitAPIException occurred in fetchGitBranches",e);
        }
        return branches;
    }


    @PutMapping("/{Portal}/{Branch}/edit")
    public void makeChangesOnVulnerabilities(@RequestBody Body body, @PathVariable("Portal") String portal,@PathVariable("Branch") String branch) {

        vulnerabilityService.makeChangesOnVulnerabilities(body, portal,branch);

    }



}
